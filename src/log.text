【2022.5.13】
尝试运行这个代码
processor.py 是用来将数据集转换为KG的
movie数据集 第一次train  耗时25min 台式机CPU
epoch 0    train auc: 0.9730  f1: 0.9200    eval auc: 0.9681  f1: 0.9141    test auc: 0.9683  f1: 0.9143
epoch 1    train auc: 0.9818  f1: 0.9372    eval auc: 0.9740  f1: 0.9245    test auc: 0.9741  f1: 0.9251
epoch 2    train auc: 0.9881  f1: 0.9506    eval auc: 0.9772  f1: 0.9311    test auc: 0.9773  f1: 0.9313
epoch 3    train auc: 0.9912  f1: 0.9586    eval auc: 0.9775  f1: 0.9315    test auc: 0.9776  f1: 0.9317
epoch 4    train auc: 0.9934  f1: 0.9643    eval auc: 0.9772  f1: 0.9311    test auc: 0.9772  f1: 0.9315
epoch 5    train auc: 0.9947  f1: 0.9684    eval auc: 0.9765  f1: 0.9300    test auc: 0.9765  f1: 0.9302
epoch 6    train auc: 0.9956  f1: 0.9717    eval auc: 0.9759  f1: 0.9297    test auc: 0.9760  f1: 0.9298
epoch 7    train auc: 0.9962  f1: 0.9739    eval auc: 0.9756  f1: 0.9288    test auc: 0.9757  f1: 0.9290
epoch 8    train auc: 0.9965  f1: 0.9755    eval auc: 0.9752  f1: 0.9284    test auc: 0.9753  f1: 0.9287
epoch 9    train auc: 0.9968  f1: 0.9767    eval auc: 0.9748  f1: 0.9277    test auc: 0.9749  f1: 0.9280
time used: 1527 s

music数据集耗时很少
epoch 0    train auc: 0.8530  f1: 0.7879    eval auc: 0.5161  f1: 0.5167    test auc: 0.5028  f1: 0.5002
epoch 1    train auc: 0.8673  f1: 0.7875    eval auc: 0.5965  f1: 0.5700    test auc: 0.5932  f1: 0.5693
epoch 2    train auc: 0.8280  f1: 0.7394    eval auc: 0.6931  f1: 0.6244    test auc: 0.6970  f1: 0.6280
epoch 3    train auc: 0.8375  f1: 0.7242    eval auc: 0.7496  f1: 0.6507    test auc: 0.7516  f1: 0.6535
epoch 4    train auc: 0.8655  f1: 0.7369    eval auc: 0.7754  f1: 0.6658    test auc: 0.7740  f1: 0.6679
epoch 5    train auc: 0.8773  f1: 0.7584    eval auc: 0.7832  f1: 0.6878    test auc: 0.7821  f1: 0.6834
epoch 6    train auc: 0.8852  f1: 0.7679    eval auc: 0.7863  f1: 0.6921    test auc: 0.7856  f1: 0.6904
epoch 7    train auc: 0.8901  f1: 0.7756    eval auc: 0.7869  f1: 0.6955    test auc: 0.7871  f1: 0.6994
epoch 8    train auc: 0.8923  f1: 0.7795    eval auc: 0.7867  f1: 0.6964    test auc: 0.7877  f1: 0.7018
epoch 9    train auc: 0.8950  f1: 0.7848    eval auc: 0.7862  f1: 0.6988    test auc: 0.7885  f1: 0.7052
time used: 13 s

新建自己的仓库 吐了  https://github.com/dingN98/KGCN

.npy 文件是在train的时候生成的  功能未知

【2022.5.14】
准备看论文  今天要看完  12:08结束
计划2：就是将这篇论文的movie知识图谱导入到neo4j里，看看到底啥样子
计划3：理解代码

【2022.5.15】
今天早上成功将 ml-1m 数据导入到 neo4j
导入实体的耗时很短，导入关系的耗时很长（100万条关系，导入了1.7小时）
然后这个知识图谱的问题是，实体的结构太简单（比如movie实体的属性在实体里面，而不是和外部实体有关系，不利于实现论文里的那种信息聚合和多跳传播）
所以，今天的计划
计划1：继续看论文的那个代码，研究下它是怎么建立KG的
计划2：重新建一个知识图谱 kg_movies_2 实体movie里面加入更多 属性实体

尝试理解preprocess.py
1、字典 item_index_old2new 作用是做一个映射，就是将【老的item的id】映射成【新的item的id】，前者是不连续的，后者是连续的。
字典 user_index_old2new同理
2、字典 user_pos_ratings 的作用是保存用户的积极评分【rating>=4】，key是【userid】,value是个集合【set】，包含该用户积极评论过的所有电影的id【movieid】
字典 user_neg_ratings 的作用的保存评分<4的数据
3、ratings_final.txt 保存着 【新的userid】、【新的itemid】、【1或者0】（1代表用户对这个电影的评分>=4，0代表用户没看过这个电影，每个用户的1和0数量一样）
4、item_index2entity_id.txt 的作用是id映射，就是把知识图谱里的【itemid】映射到【连续的itemid】
5、kg.txt是movie知识图谱，三个字段分别是【电影实体id】、【关系】、【其他实体id】

现在可以确定的是，KGCN的作者构建了一个movie知识图谱，其中的【实体】包含以下：【电影id】、【genre】、【actor】、【producer】、【director】、【star】、【language】等等。
其中的【关系】是一种三级结构，典型的实例【film.film.actor】、【film.film.language】、【media_common.creative_work.honors】等等。
然后作者从这个知识图谱里将【电影实体-关系-其他实体】三元组提取出来，存储在kg.txt里，一个实例是【11904	film.film.producer	16954】，
作者对kg.txt做了预处理，就是将文本关系映射成数字，最后结果是32个关系，6036个user，16954个item，102569个实体（包含item）。

